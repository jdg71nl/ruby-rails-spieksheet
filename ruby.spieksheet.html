<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title>Ruby.SS</title>
  <link rel="stylesheet" href="styles/default.css"> <!-- https://highlightjs.org/usage/ -->
  <script src="highlight.pack.js"></script> <script>hljs.initHighlightingOnLoad();</script>
</head>
<style>
  body { margin:0; border:0; padding: 1em; font-family: tahoma, Arial, verdana, "Lucida Sans Unicode"; font-size: 1em; }
  pre { border: solid 1px black;}
</style>
<body>
  <h3>Ruby.SS (SpiekSheet)</h3>
  <!-- - - - + - - - - - - + - - - - - - + - - - - - - + - - - - - - + - - - - - - + - - - -->

  <pre><code class="ruby">
    # variable
    $global_var = 12 # convention: var in 'snake_case'
    def global_method
      local_var = 34
      ["one", "two"].reverse.each {|block_var| puts "#{ block_var.capitalize }" }
    end
    class ClassInCamelCase
      def Classmethod
        @@class_var = 56
        @instance_var = 78
      end
    end
    100.class # returns name of the class
    MY_CONSTANT = 90 # convention is all-caps, but Ruby only inspects first letter to be capital

    # string
    my_string = "Hello"
    puts my_string + ' ' + "World!"
    "Yada " * 3 # returns "Yada Yada Yada "
    escaped_string = 'Let\'s escape!'

    # array
    my_array = [1,2,3, "also a string is allowed"]
    my_array << 'appended'
    my_array << ['appended array', 'some more']
    my_array[0] = "zero-based index"
    my_array[-1] # returns ["appended array", "some more"]
    my_array[-2] # returns "appended"
    my_array.length # synonym: my_array.size
    my_array.reverse! # use '!' to save the string in place
    my_array.push # .pop .shift .unshift
    [1,2,3] + [4,5,6] # concatenate arrays

    # hash
    my_hash = {'key1' => 'value1', 'key2' => 'value2'}
    my_hash.keys
    my_hash.values
    my_hash['key1'] = 'new value1'
    my_hash.to_a # convert to array, returns: [["key1", "new value1"], ["key2", "value2"]]

    # symbol
    # Symbol is kind of 'read-only-string', start with colon, no delimiters, used as keys in hash
    :my_symbol.class # returns Symbol
    my_hash = {"string_key" => "value1", :symbol_key => "value2"}
    my_hash["string_key"] # returns "value1"
    my_hash[:symbol_key]  # returns "value2"
    # symbols are global unique instance-like things:
    "string".object_id  # 70253774726280
    "string".object_id  # 70253774744700
    :symbol.object_id   # 881628
    :symbol.object_id   # 881628
    equivalent_hash = {:low => 2, :high => 8, :avg => 6} # rocket notation
    equivalent_hash = {low: 2, high: 8, avg: 6} # shorthand notation

    # boolean
    my_boolean = true
    my_boolean = false
    # comparisons: == < > <= >= ! != && ||
    [1,2,3].include?(1)     # true
    2.between?(1,5)         # true
    {'a'=>1}.has_key?('a')  # true
    {'a'=>1}.has_key?(:a)   # false
    {'a'=>1}.has_value?(1)  # true

    # range
    inclusive_range = 1..10    #
    exclusive_range = 1...10   #
    exclusive_range = *1...10  # convert to array: [1, 2, 3, 4, 5, 6, 7, 8, 9]
    (1..10).class  # Range
    (1..10).first  #  1, alias: begin
    (1..10).last   # 10, alias: end
    ('a'..'m').include?('g')  # true

    # nil
    my_nil_var = nil
    my_nil_var == false  # false
    my_nil_var == nil    # true
    my_nil_var.nil?      # true
    !my_nil_var          # true
    my_test_var = my_nil_var || 'default value'  # "default value"

    # control structures
    #
    if boolean_expression_1
      statement_1
    elsif boolean_expression_2
      statement_2
    else
      statement_3
    end
    #
    unless boolean_expression  # is negation of if..end
      statement_1
    end
    #
    case                         # note: no 'variable' after case
    when boolean_expression_1
      statement_1
    when boolean_expression_2
      statement_2
    else
      statement_3
    end
    #
    case integer_test_variable
    when 1
      statement_1
    when 2..5
      statement_2
    else
      statement_3
    end
    #
    result = boolean_expression ? "value if true" | "value if false"
    #
    result = variable_possibly_nil_or_false || variable_default
    x ||= y  # equivalent to: x = y unless x

    # loop structures
    i = 5
    loop do
      break if i <= 0
      puts "Countdown: #{i}"
      i -= 1
    end
    #
    i = 5
    while i > 0
      puts "Countdown: #{i}"
      i -= 1
    end
    #
    i = 5
    until i <= 0
      puts "Countdown: #{i}"
      i -= 1
    end

    # iterator
    i = 5
    i.times do
      puts "Countdown: #{i}"
      i -= 1
    end
    #
    5.times     { puts "some" }
    1.upto(5)   { puts "some" }
    5.downto(1) { puts "some" }
    (1..5).each { puts "some" }
    #
    5.downto(1) do |i|
      puts "Countdown: #{i}"
    end
    #
    5.downto(1) {|i| puts "Countdown: #{i}"}
    #
    numbers : .times .upto .downto .step
    range   : .each .step
    string  : .each_line .each_char .each_byte
    array   : .each .each_index .each_with_index
    hash    : .each .each_key .each_value .each_pair
    https://ruby-doc.org/core-2.7.2/Hash.html#method-i-each_pair
    #
    fruits = ['banana', 'apple', 'pear']
    fruits.each {|fruit| puts fruit.capitalize}
    for fruit in fruits {puts fruit.capitalize}
    [1,2,3].each {|x| puts "#{x}"}
    



  </code></pre>

 <!-- - - - + - - - - - - + - - - - - - + - - - - - - + - - - - - - + - - - - - - + - - - -->
  <!--
    <pre><code class="html">...</code></pre>
    <pre><code class="plaintext">...</code></pre>
    <pre><code class="nohighlight">...</code></pre>
  -->
</body>
</html>
